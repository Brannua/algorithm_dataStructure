/**
 * 注意：此算法仅以矩阵相乘为背景，作为分析时间复杂度的示范，并不做具体的算法实现
 */

#include <stdio.h>

int main() {

    int n = 10;
    int a[3][4] = {},
        b[3][4] = {},
        c[3][4] = {};

    for (int i = 1; i <= n; i++) {                      // n + 1            次，+1 是循环终止的判断
        for (int j = 1; j <= n; j ++) {                 // n * (n + 1)      次，+1 是循环终止的判断
            c[i][j] = 0;                                // n * n            次
            for (int k = 0; k < n; k ++) {              // n * n * (n + 1)  次，+1 是循环终止的判断
                c[i][j] = c[i][j] + a[i][k] * b[k][j];  // n * n * n        次
            }
        }
    }

    return 0;
}

// 即 算法的时间消耗为 T(n) = (n + 1) + (n * (n + 1)) + (n * n) + (n * n * (n + 1)) + (n * n * n)
//                       = 2 * n^3 + 3 * n^2 + 2 * n + 1

// 为了比较不同算法的时间效率，我们仅需要比较不同算法时间效率的数量级。

// 算法的渐进时间复杂度（时间复杂度）的定义：
    // 若有某个辅助函数 f(n), 使得当 n 趋近于 ∞ 时, T(n) / f(n) 的极限值是 **非零常数**
    // 则称 f(n) 是 T(n) 的同数量级函数, 记作：T(n) = O(f(n))
    // 因为 T(n) = O(f(n)) 表示随着 n 的增大，算法执行的时间的增长率和 f(n) 的增长率相同，所以称 O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度
    // [注]：f(n) 是问题规模 n 的函数，是算法中基本语句重复执行的次数
    // [注]：O 是数量级的符号

// n -> ∞ 时，T(n) / n^3 -> 2
// 所以，T(n) = O(n^3)